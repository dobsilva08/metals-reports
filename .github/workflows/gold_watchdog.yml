name: Gold — Watchdog (Backup de Envio)

on:
  schedule:
    # 09:30 UTC ≙ 06:30 BRT — roda depois do principal (que roda às 06:00 BRT)
    - cron: "30 9 * * *"
  workflow_dispatch:

concurrency:
  group: metals-gold-watchdog
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      # ===== LLM (padrão: PIAPI) =====
      PIAPI_API_KEY: ${{ secrets.PIAPI_API_KEY }}
      PIAPI_MODEL: ${{ secrets.PIAPI_MODEL || 'gpt-4o-mini' }}

      # Fallbacks (opcionais)
      GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
      GROQ_MODEL: ${{ secrets.GROQ_MODEL || 'llama-3.1-70b-versatile' }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      OPENAI_MODEL: ${{ secrets.OPENAI_MODEL || 'gpt-4o-mini' }}
      DEEPSEEK_API_KEY: ${{ secrets.DEE PSEEK_API_KEY || '' }}
      DEEPSEEK_MODEL: ${{ secrets.DEEPSEEK_MODEL || 'deepseek-chat' }}

      LLM_PROVIDER: piapi
      LLM_FALLBACK_ORDER: piapi,groq,openai,deepseek

      # ===== Telegram =====
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID_METALS: ${{ secrets.TELEGRAM_CHAT_ID_METALS }}
      TELEGRAM_CHAT_ID_TEST: ${{ secrets.TELEGRAM_CHAT_ID_TEST }}
      TELEGRAM_MESSAGE_THREAD_ID: ${{ secrets.TELEGRAM_MESSAGE_THREAD_ID }}

      # ===== Dados (opcionais) =====
      FRED_API_KEY: ${{ secrets.FRED_API_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Instalar dependências
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: (Opcional) Verificar PiAPI
        if: ${{ env.PIAPI_API_KEY != '' }}
        continue-on-error: true
        run: |
          python scripts/tools/check_piapi.py

      - name: Check main workflow (há envio hoje?)
        id: check_main
        run: |
          python - <<'PY'
import os,sys,requests
from datetime import datetime, timezone, timedelta

# Ajuste caso o arquivo do workflow principal tenha nome diferente
candidate_filenames = ["gold_daily.yml", "gold_daily.yaml"]

repo = os.environ.get("GITHUB_REPOSITORY")
token = os.environ.get("GITHUB_TOKEN")
if not repo or not token:
    print("GITHUB_REPOSITORY or GITHUB_TOKEN not set")
    sys.exit(1)

headers = {
    "Authorization": f"Bearer {token}",
    "Accept": "application/vnd.github+json",
    "X-GitHub-Api-Version": "2022-11-28",
}

# 1) listar workflows e tentar localizar o workflow id
wf_list_resp = requests.get(f"https://api.github.com/repos/{repo}/actions/workflows", headers=headers, timeout=30)
if wf_list_resp.status_code != 200:
    print("Failed to list workflows:", wf_list_resp.status_code, wf_list_resp.text[:500])
    sys.exit(1)
wf_list = wf_list_resp.json().get("workflows", [])

wf_id = None
for w in wf_list:
    path = w.get("path","") or ""
    # tentar por path
    for fn in candidate_filenames:
        if path.endswith(fn):
            wf_id = w.get("id")
            break
    if wf_id:
        break

# fallback: tentar por name que contenha 'gold'
if not wf_id:
    for w in wf_list:
        if "gold" in (w.get("name","") or "").lower():
            wf_id = w.get("id")
            break

if not wf_id:
    print("Workflow file not found (tried filenames and names containing 'gold').")
    sys.exit(1)

# 2) buscar runs (paginar até 300 runs)
workflow_runs = []
per_page = 100
for page in range(1,4):
    runs_resp = requests.get(
        f"https://api.github.com/repos/{repo}/actions/workflows/{wf_id}/runs?per_page={per_page}&page={page}",
        headers=headers, timeout=30
    )
    if runs_resp.status_code != 200:
        print("Failed to fetch workflow runs:", runs_resp.status_code, runs_resp.text[:500])
        sys.exit(1)
    part = runs_resp.json().get("workflow_runs", [])
    if not part:
        break
    workflow_runs.extend(part)

# 3) calcular 'hoje' em BRT
BRT_offset = timedelta(hours=-3)
now_utc = datetime.now(timezone.utc)
today_brt = (now_utc + BRT_offset).date()

# 4) procurar qualquer run com conclusion == 'success' e created_at no dia de hoje (em BRT)
found = False
for r in workflow_runs:
    if r.get("conclusion") != "success":
        continue
    created_at = r.get("created_at")
    if not created_at:
        continue
    try:
        dt_utc = datetime.fromisoformat(created_at.replace("Z","+00:00"))
    except Exception:
        continue
    dt_brt = dt_utc + BRT_offset
    if dt_brt.date() == today_brt:
        found = True
        break

if found:
    print("FOUND_SUCCESS_TODAY")
    sys.exit(0)   # OK — watchdog should not run
else:
    print("NOT_FOUND_SUCCESS_TODAY")
    sys.exit(1)   # trigger watchdog run
PY

      - name: Rodar Watchdog (executa se não houver envio principal hoje)
        if: ${{ steps.check_main.outcome == 'failure' }}
        run: |
          echo "Nenhum envio bem-sucedido do workflow principal detectado hoje (BRT). Rodando gold_daily.py..."
          # opcional: notificar no Telegram antes de rodar (útil para auditoria)
          if [ -n "${{ env.TELEGRAM_BOT_TOKEN }}" ] && [ -n "${{ env.TELEGRAM_CHAT_ID_METALS }}" ]; then
            PREVIEW_MSG="Watchdog GOLD disparado às $(date -u +'%Y-%m-%dT%H:%M:%SZ') (UTC) — rodando gold_daily.py"
            curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -H "Content-Type: application/json" \
              -d "{\"chat_id\": \"${{ env.TELEGRAM_CHAT_ID_METALS }}\", \"text\": \"${PREVIEW_MSG}\", \"parse_mode\": \"HTML\", \"disable_web_page_preview\": true}" || true
          fi
          python ./scripts/gold_daily.py --send-telegram

      - name: No-op quando já enviado hoje
        if: ${{ steps.check_main.outcome == 'success' }}
        run: |
          echo "Envio principal detectado hoje. Watchdog não executa."
